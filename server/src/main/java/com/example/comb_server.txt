package com.example;

public class ClientCommandProcessor {

    private final ClientHandler client;
    private final RoomActionHandler roomHandler;
    private final GameActionHandler gameHandler;

    public ClientCommandProcessor(ClientHandler client) {
        this.client = client;
        this.roomHandler = new RoomActionHandler(client);
        this.gameHandler = new GameActionHandler(client);
    }

    public void processMessage(Message msg) {
        switch (msg.type) {
            case SET_NAME -> handleSetName(msg);
            //TODO: Add swap thingys
            case CREATE_ROOM, LIST_ROOMS, LIST_PLAYERS, JOIN, LEAVE_ROOM, PICK_COLOR, BEGIN ->
                roomHandler.handleMessage(msg);
            case MOVE, PASS, RESIGN ->
                gameHandler.handleMessage(msg);
            default -> sendUnknownCommand(msg);
        }
    }

    private void handleSetName(Message msg) {
        if (msg.nick == null || msg.nick.isBlank()) {
            sendError("Invalid username");
            return;
        }

        client.username = msg.nick;

        Message response = new Message();
        response.type = MessageType.NICK_SET;
        response.nick = client.username;
        client.sendMessage(response);
    }

    private void sendUnknownCommand(Message msg) {
        Message response = new Message();
        response.type = MessageType.UNKNOWN;
        client.sendMessage(response);
    }

    private void sendError(String text) {
        Message response = new Message();
        response.type = MessageType.ERROR;
        response.nick = text;
        client.sendMessage(response);
    }
}

package com.example;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.net.Socket;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

public class ClientHandler implements Runnable {

    private final Socket socket;
    private final ClientManager clientManager;
    private final RoomManager roomManager;
    private ObjectInputStream in;
    private ObjectOutputStream out;
    private boolean running;

    public String username;
    private Room currentRoom;
    private final BlockingQueue<PlayerAction> actionQueue = new LinkedBlockingQueue<>();
    private final ClientCommandProcessor processor;

    public ClientHandler(Socket socket, ClientManager cm, RoomManager rm) {
        this.socket = socket;
        this.clientManager = cm;
        this.roomManager = rm;
        this.processor = new ClientCommandProcessor(this);
        this.running = true;

        try {
            this.out = new ObjectOutputStream(socket.getOutputStream());
            this.in = new ObjectInputStream(socket.getInputStream());
        } catch (IOException e) {
            Logger.error("Error initializing client streams", e);
        }

        this.username = null;
        this.currentRoom = null;
        clientManager.addClient(this);
    }

    @Override
    public void run() {
        try {
            while (running) {
                Object obj = in.readObject();
                if (obj instanceof Message msg) {
                    processor.processMessage(msg);
                }
            }
        } catch (Exception e) {
            Logger.error("Client disconnected: " + socket.getInetAddress(), e);
        } finally {
            cleanup();
        }
    }

    public void sendMessage(Message msg) {
        try {
            out.writeObject(msg);
            out.flush();
        } catch (IOException e) {
            Logger.error("Failed to send message to client", e);
        }
    }

    public void submitAction(PlayerAction action) { actionQueue.offer(action); }
    public PlayerAction waitForAction() throws InterruptedException { return actionQueue.take(); }

    public Room getCurrentRoom() { return currentRoom; }
    public void setCurrentRoom(Room room) { this.currentRoom = room; }
    public RoomManager getRoomManager() {
        return this.roomManager;
    }


    private void cleanup() {
        running = false;
        clientManager.removeClient(this);
        if (currentRoom != null) currentRoom.leave(this);
        try {
            in.close();
            out.close();
            socket.close();
        } catch (IOException ignored) {}
    }
}

package com.example;

import java.util.ArrayList;
import java.util.List;

public class ClientManager {
    private final List<ClientHandler> clients;

    public ClientManager() {
        clients = new ArrayList<>();
    }

    public synchronized void addClient(ClientHandler client) {
        clients.add(client);
        System.out.println("Client added. Total clients: " + clients.size());
    }

    public synchronized void removeClient(ClientHandler client) {
        clients.remove(client);
        System.out.println("Client removed. Total clients: " + clients.size());
    }

    public synchronized int getClientCount() {
        return clients.size();
    }
}
package com.example;

public class GameActionHandler {

    private final ClientHandler client;

    public GameActionHandler(ClientHandler client) {
        this.client = client;
    }

    public void handleMessage(Message msg) {
        Room room = client.getCurrentRoom();

        if (room == null || !room.isStarted()) {
            sendError("Game has not started.");
            return;
        }

        StoneColor stoneColor = room.getColor(client);

        try {
            switch (msg.type) {
                case MOVE -> handleMove(msg, stoneColor);
                case PASS -> client.submitAction(PlayerAction.pass());
                case RESIGN -> client.submitAction(PlayerAction.resign());
                default -> sendError("Unknown game command: " + msg.type);
            }
        } catch (Exception e) {
            sendError("Invalid move: " + e.getMessage());
        }
    }

    private void handleMove(Message msg, StoneColor stoneColor) throws Exception {
        Move move = msg.move;

        if (move == null) {
            sendError("Move is missing in the message.");
            return;
        }

        // Ensure the move has the correct color assigned from the player
        Move coloredMove = new Move(move.getX(), move.getY(), stoneColor);
        client.submitAction(PlayerAction.move(coloredMove));
    }

    private void sendError(String text) {
        Message m = new Message();
        m.type = MessageType.ERROR;
        m.error = text; // reuse nick field for errors
        client.sendMessage(m);
    }
}

package com.example;

import java.util.ArrayList;
import java.util.List;

public class GameLogic {

    private final Room room;
    private final Board board;

    public GameLogic(Room room) {
        this.room = room;
        this.board = new Board(19); // default 19x19 board
    }

    /**
     * Attempt to play a move. Returns true if legal.
     */
    public boolean tryMove(Move move) {
        int x = move.getX();
        int y = move.getY();
        StoneColor color = move.getState(); // updated to StoneColor

        // Check if coordinates are in bounds
        if (x < 1 || x > board.getSize() || y < 1 || y > board.getSize()) return false;

        // Check if intersection is empty
        if (board.getInterSec(x, y) != StoneColor.EMPTY_STONE) return false;

        // Tentatively place stone
        board.setInterSec(x, y, color);

        // Check for captures
        removeCapturedStones(opposite(color));

        // Check for suicide (if the stone has no liberties after placement)
        if (!hasLiberty(x, y)) {
            board.setInterSec(x, y, StoneColor.EMPTY_STONE); // undo
            return false;
        }

        return true;
    }

    /** Remove all opponent stones that have no liberties */
    private void removeCapturedStones(StoneColor opponent) {
        boolean[][] visited = new boolean[board.getSize()][board.getSize()];

        for (int i = 1; i <= board.getSize(); i++) {
            for (int j = 1; j <= board.getSize(); j++) {
                if (!visited[i - 1][j - 1] && board.getInterSec(i, j) == opponent) {
                    List<int[]> group = new ArrayList<>();
                    if (!groupHasLiberty(i, j, opponent, visited, group)) {
                        // remove stones
                        for (int[] pos : group) {
                            board.setInterSec(pos[0], pos[1], StoneColor.EMPTY_STONE);
                        }
                    }
                }
            }
        }
    }

    /**
     * Check if a group has at least one liberty (DFS).
     */
    private boolean groupHasLiberty(int x, int y, StoneColor color, boolean[][] visited, List<int[]> group) {
        int size = board.getSize();
        if (x < 1 || x > size || y < 1 || y > size) return false;
        if (visited[x - 1][y - 1]) return false;

        visited[x - 1][y - 1] = true;
        StoneColor current = board.getInterSec(x, y);
        if (current == StoneColor.EMPTY_STONE) return true;
        if (current != color) return false;

        group.add(new int[]{x, y});

        boolean hasLiberty = false;
        int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
        for (int[] d : dirs) {
            int nx = x + d[0];
            int ny = y + d[1];
            if (nx >= 1 && nx <= size && ny >= 1 && ny <= size && !visited[nx - 1][ny - 1]) {
                if (board.getInterSec(nx, ny) == StoneColor.EMPTY_STONE) hasLiberty = true;
                else if (board.getInterSec(nx, ny) == color)
                    hasLiberty |= groupHasLiberty(nx, ny, color, visited, group);
            }
        }
        return hasLiberty;
    }

    /** Check if the stone at x,y has any liberties */
    private boolean hasLiberty(int x, int y) {
        boolean[][] visited = new boolean[board.getSize()][board.getSize()];
        List<int[]> group = new ArrayList<>();
        return groupHasLiberty(x, y, board.getInterSec(x, y), visited, group);
    }

    /** Get the opposite stone color */
    private StoneColor opposite(StoneColor color) {
        return switch (color) {
            case BLACK_STONE -> StoneColor.WHITE_STONE;
            case WHITE_STONE -> StoneColor.BLACK_STONE;
            default -> StoneColor.EMPTY_STONE;
        };
    }

    public Board getBoard() {
        return board;
    }
}

package com.example;

public class GameSession implements Runnable {

    private final Room room;
    private final GameLogic logic;

    public GameSession(Room room) {
        this.room = room;
        this.logic = room.getGameLogic();
    }

    @Override
    public void run() {
        ClientHandler blackPlayer = null;
        ClientHandler whitePlayer = null;

        // Assign players by color
        for (ClientHandler p : room.getPlayers()) {
            StoneColor color = room.getColor(p);
            if (color == StoneColor.BLACK_STONE) blackPlayer = p;
            else if (color == StoneColor.WHITE_STONE) whitePlayer = p;
        }

        if (blackPlayer == null || whitePlayer == null) {
            broadcastError("Both players must pick colors.");
            return;
        }

        ClientHandler currentPlayer = blackPlayer;
        ClientHandler otherPlayer = whitePlayer;
        int consecutivePasses = 0;

        // Initial board
        broadcastBoard();

        while (true) {
            try {
                // Notify current player it's their turn
                Message yourTurnMsg = new Message();
                yourTurnMsg.type = MessageType.YOUR_TURN;
                yourTurnMsg.nick = currentPlayer.username;
                currentPlayer.sendMessage(yourTurnMsg);

                // Wait for player action
                PlayerAction action = currentPlayer.waitForAction();

                // Resign
                if (action.isResign()) {
                    broadcastInfo(currentPlayer.username + " resigned. Game over.");
                    break;
                }

                // Pass
                if (action.isPass()) {
                    broadcastInfo(currentPlayer.username + " passed.");
                    consecutivePasses++;
                }
                // Move
                else {
                    Move move = action.getMove();
                    boolean legal = logic.tryMove(move);

                    if (!legal) {
                        Message illegalMsg = new Message();
                        illegalMsg.type = MessageType.INVALID_MOVE;
                        illegalMsg.board = logic.getBoard();
                        currentPlayer.sendMessage(illegalMsg);
                        continue; // retry same player
                    }

                    // Broadcast move to all
                    Message moveMsg = new Message();
                    moveMsg.type = MessageType.MOVE;
                    moveMsg.nick = currentPlayer.username;
                    moveMsg.move = move;      // new Move field in Message
                    moveMsg.board = logic.getBoard(); // include updated board
                    room.broadcast(moveMsg);

                    consecutivePasses = 0;
                }

                broadcastBoard();

                // End game if both passed
                if (consecutivePasses >= 2) {
                    broadcastInfo("Both players passed consecutively. Game over.");
                    break;
                }

                // Swap turns
                ClientHandler temp = currentPlayer;
                currentPlayer = otherPlayer;
                otherPlayer = temp;

            } catch (InterruptedException e) {
                broadcastError("Game session interrupted.");
                break;
            }
        }
    }

    /** Broadcast the current board state to all players */
    private void broadcastBoard() {
        Message boardMsg = new Message();
        boardMsg.type = MessageType.BOARD_UPDATE;
        boardMsg.board = logic.getBoard();
        room.broadcast(boardMsg);
    }

    /** Helper to broadcast a simple text info message */
    private void broadcastInfo(String text) {
        Message msg = new Message();
        msg.type = MessageType.INFO; // add INFO to MessageType
        msg.nick = text;
        room.broadcast(msg);
    }

    /** Helper to broadcast errors */
    private void broadcastError(String text) {
        Message msg = new Message();
        msg.type = MessageType.ERROR;
        msg.nick = text;
        room.broadcast(msg);
    }
}

package com.example;

public class PlayerAction {
    private final Move move;    // null if pass
    private final boolean resign;

    private PlayerAction(Move move, boolean resign) {
        this.move = move;
        this.resign = resign;
    }

    public static PlayerAction move(Move move) {
        return new PlayerAction(move, false);
    }

    public static PlayerAction pass() {
        return new PlayerAction(null, false);
    }

    public static PlayerAction resign() {
        return new PlayerAction(null, true);
    }

    public Move getMove() { return move; }
    public boolean isPass() { return move == null && !resign; }
    public boolean isResign() { return resign; }
}
package com.example;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class Room {
    private final String roomId;
    private final String roomName;
    private ClientHandler owner;
    private final List<ClientHandler> players = new ArrayList<>();
    private boolean started = false;
    private final Map<ClientHandler, StoneColor> colors = new HashMap<>();
    private ClientHandler colorChangeRequester = null;

    private GameLogic gameLogic; // Holds the board and rules

    public Room(String roomId, String roomName, ClientHandler owner) {
        this.roomId = roomId;
        this.roomName = roomName;
        this.owner = owner;
    }

    public synchronized void start() {
        if (!started && players.size() == 2) {
            started = true;
        }
    }

    public boolean isStarted() { return started; }

    public List<ClientHandler> getPlayers() { return players; }

    public ClientHandler getOwner() { return owner; }

    public boolean isOwner(ClientHandler client) { return owner == client; }

    public void setOwner(ClientHandler newOwner) { this.owner = newOwner; }

    // UPDATED: use StoneColor
    public synchronized StoneColor getColor(ClientHandler player) {
        return colors.getOrDefault(player, StoneColor.EMPTY_STONE);
    }

    public synchronized boolean pickColor(ClientHandler player, StoneColor color) {
        if (started)
            return false;

        if (colors.get(player) != null && colors.get(player) != StoneColor.EMPTY_STONE)
            return false;

        if (colors.containsValue(color))
            return false;

        colors.put(player, color);

        // assign remaining color to other player
        for (ClientHandler p : players) {
            if (p != player)
                colors.put(p, color == StoneColor.BLACK_STONE ? StoneColor.WHITE_STONE : StoneColor.BLACK_STONE);
        }
        return true;
    }

    public synchronized boolean colorsChosen() {
        return colors.values().stream().noneMatch(c -> c == StoneColor.EMPTY_STONE);
    }

    public synchronized void broadcast(Message msg) {
        for (ClientHandler player : players)
            player.sendMessage(msg);
    }

    public synchronized GameLogic getGameLogic() {
        return gameLogic;
    }

    public synchronized boolean join(ClientHandler client) {
        if (players.size() < 2) {
            players.add(client);
            colors.put(client, StoneColor.EMPTY_STONE);
            return true;
        }
        return false;
    }

    public synchronized void leave(ClientHandler client) {
        players.remove(client);
        colors.remove(client);
        if (client == owner && !players.isEmpty()) {
            owner = players.get(0);
        }
    }

    public String getRoomId() { return roomId; }

    public String getRoomName() { return roomName; }

    // Color change methods
    public synchronized void setColorChangeRequester(ClientHandler client) { colorChangeRequester = client; }

    public synchronized ClientHandler getColorChangeRequester() { return colorChangeRequester; }

    public synchronized void clearColorChangeRequest() { colorChangeRequester = null; }

    public synchronized boolean canRespondToColorChange(ClientHandler player) {
        return colorChangeRequester != null && player != colorChangeRequester;
    }

    public synchronized void swapColors(ClientHandler a, ClientHandler b) {
        StoneColor temp = colors.get(a);
        colors.put(a, colors.get(b));
        colors.put(b, temp);
    }
}

package com.example;

import java.util.List;

public class RoomActionHandler {

    private final ClientHandler client;
    private final RoomManager roomManager;

    public RoomActionHandler(ClientHandler client) {
        this.client = client;
        this.roomManager = client.getRoomManager();
    }

    public void handleMessage(Message msg) {
        switch (msg.type) {
            case CREATE_ROOM -> handleCreateRoom(msg.roomName);
            case LIST_ROOMS -> handleListRooms();
            case JOIN -> handleJoinRoom(msg.roomName); // reuse roomName as roomId
            case LEAVE_ROOM -> handleLeaveRoom();
            case PICK_COLOR -> handlePickColor(msg.color);
            case BEGIN -> handleBeginGame();
            default -> sendUnknown(msg);
        }
    }

    private void handleCreateRoom(String roomName) {
        if (client.username == null || client.username.isBlank()) {
            sendError("You must set a username before creating a room.");
            return;
        }
        Room room = roomManager.createRoom(roomName, client);
        roomManager.joinRoom(room.getRoomId(), client);

        Message response = new Message();
        response.type = MessageType.ROOM_CREATED;
        response.roomName = room.getRoomName();
        client.sendMessage(response);
    }

    private void handleJoinRoom(String roomId) {
        if (roomManager.joinRoom(roomId, client)) {
            Message response = new Message();
            response.type = MessageType.JOIN;
            response.roomName = roomId;
            client.sendMessage(response);
        } else sendError("Failed to join room.");
    }

    private void handleLeaveRoom() {
        Room room = client.getCurrentRoom();
        if (room != null) {
            roomManager.leaveRoom(client);
            Message response = new Message();
            response.type = MessageType.LEAVE_ROOM;
            response.roomName = room.getRoomName();
            client.sendMessage(response);
        } else sendError("You are not in a room.");
    }

    private void handleListRooms() {
        List<String> rooms = roomManager.listRooms();
        Message response = new Message();
        response.type = MessageType.LIST_ROOMS;
        response.roomList = rooms.toArray(new String[0]);
        client.sendMessage(response);
    }

    // UPDATED: use StoneColor instead of Color
    private void handlePickColor(StoneColor color) {
        Room room = client.getCurrentRoom();
        if (room == null) { 
            sendError("You are not in a room."); 
            return; 
        }

        if (room.pickColor(client, color)) {
            room.broadcast(buildMessage(MessageType.PICK_COLOR, client.username, color.name()));
        } else sendError("Color not available.");
    }

    private void handleBeginGame() {
        Room room = client.getCurrentRoom();
        if (room == null || !room.isOwner(client) || !room.colorsChosen()) {
            sendError("Cannot start game yet.");
            return;
        }

        room.start();
        room.broadcast(buildMessage(MessageType.BEGIN, "Game started!"));
        new Thread(new GameSession(room)).start();
    }

    private void sendUnknown(Message msg) {
        sendError("Unknown room command: " + msg.type);
    }

    private void sendError(String text) {
        Message m = new Message();
        m.type = MessageType.ERROR;
        m.nick = text; // reuse nick/message field for errors
        client.sendMessage(m);
    }

    private Message buildMessage(MessageType type, String... params) {
        Message m = new Message();
        m.type = type;
        if (params.length > 0) m.nick = params[0];
        return m;
    }
}

package com.example;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.stream.Collectors;

public class RoomManager {
    private final Map<String, Room> rooms = new HashMap<>();

    public synchronized Room createRoom(String roomName, ClientHandler owner) {
        String roomId = generateUniqueId();
        Room room = new Room(roomId, roomName, owner);
        rooms.put(roomId, room);
        return room;
    }

    public synchronized boolean joinRoom(String roomId, ClientHandler client) {
        if (client.getCurrentRoom() != null) return false;

        Room room = rooms.get(roomId);
        if (room != null) {
            boolean success = room.join(client);
            if (success) {
                client.setCurrentRoom(room);
                return true;
            }
        }
        return false;
    }

    public synchronized void leaveRoom(ClientHandler client) {
        Room room = client.getCurrentRoom();
        if (room == null) return;

        room.leave(client);
        client.setCurrentRoom(null);

        if (room.getPlayers().isEmpty()) {
            rooms.remove(room.getRoomId());
        } else if (room.getOwner() == client) {
            ClientHandler newOwner = room.getPlayers().get(0);
            room.setOwner(newOwner);

            Message m = new Message();
            m.type = MessageType.NEW_OWNER; // <-- add this to MessageType
            m.nick = newOwner.username;
            room.broadcast(m);
        }
    }

    public synchronized Room getRoom(String roomId) {
        return rooms.get(roomId);
    }

    public synchronized void removeRoom(String roomId) {
        rooms.remove(roomId);
    }

    private String generateUniqueId() {
        String id;
        do {
            id = UUID.randomUUID().toString().substring(0, 8);
        } while (rooms.containsKey(id));
        return id;
    }

    public synchronized List<String> listRooms() {
        return rooms.values().stream()
                .map(room -> room.getRoomId() + " - " + room.getRoomName())
                .collect(Collectors.toList());
    }
}

package com.example;

import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;

public class Server {
    private static final int PORT = 1664;
    private ServerSocket serverSocket;
    private static boolean running;

    private final ClientManager clientManager = new ClientManager();
    private final RoomManager roomManager = new RoomManager();

    public void start() {
        try {
            running = true;
            serverSocket = new ServerSocket(PORT);
            Logger.info("Server started on port: " + PORT);

            while (running) {
                Socket clientSocket = serverSocket.accept();
                Logger.info("New client connected: " + clientSocket.getInetAddress());

                ClientHandler handler = new ClientHandler(clientSocket, clientManager, roomManager);
                new Thread(handler).start();
            }
        } catch (IOException e) {
            Logger.error("Server error: ",  e);
        } finally {
            Logger.info("Server stopped.");
            stop();
        }
    }

    public void stop() {
        try {
            if (serverSocket != null) serverSocket.close();
            Logger.info("Server stopped.");
        } catch (IOException e) {
            Logger.error("Error closing server: ", e);
        }
    }

    public void kill() { running = false; }

    public static void main(String[] args) {
        new Server().start();
    }
}
